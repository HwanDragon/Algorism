#include <iostream>
#include <vector>
#include <queue>

using namespace std;

#define INF 1000000000	// 무한대의 값을 표현
#define NODE_COUNT 6	// 정점의 개수

/*
최단거리
정답 : 0 2 3 1 2 4
*/

// 간선 정보를 저장할 배열
vector<pair<int, int>> edges[NODE_COUNT];

int dists[NODE_COUNT] = { 0, };

void dijkstra(int startNode)
{
	// 우선순위큐 {거리, 노드번호} 추가
	priority_queue <pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
	pq.push({0, startNode});	// 처음에 시작노드까지 가는 비용 추가
	dists[startNode] = 0;

	while (pq.empty() == false)
	{
		pair<int, int> p = pq.top();
		int dist = p.first;
		int current = p.second;
		pq.pop();

		if (dists[current] < dist)	continue;	// 이미 더 적은 비용을 가짐

		for (int i = 0; i < edges[current].size(); i++)
		{
			pair<int, int> next = edges[current].at(i);
			int nextDist = next.first;
			int nextNode = next.second;

			if (dists[nextNode] > dist + nextDist)
			{
				dists[nextNode] = dist + nextDist;
				pq.push({ dist + nextDist , nextNode});
			}
		}
	}
}

void print()
{
	for (int i = 0; i < NODE_COUNT; i++)
	{
		if (dists[i] == INF)
			cout << "INF" << " ";
		else
			cout << dists[i] << " ";
	}
}


int main()
{
	for (int i = 0; i < NODE_COUNT; i++) dists[i] = INF;
		
	edges[0].push_back({ 2, 1 });	// {거리, 다음 노드}
	edges[0].push_back({ 5, 2 });
	edges[0].push_back({ 1, 3 });

	edges[1].push_back({ 2, 0 });
	edges[1].push_back({ 2, 3 });
	edges[1].push_back({ 3, 2 });

	edges[2].push_back({ 5, 0 });
	edges[2].push_back({ 3, 1 });
	edges[2].push_back({ 3, 3 });
	edges[2].push_back({ 1, 4 });
	edges[2].push_back({ 5, 5 });

	edges[3].push_back({ 1, 0 });
	edges[3].push_back({ 2, 1 });
	edges[3].push_back({ 3, 2 });
	edges[3].push_back({ 1, 4 });

	edges[4].push_back({ 1, 2 });
	edges[4].push_back({ 1, 3 });
	edges[4].push_back({ 2, 5 });

	edges[5].push_back({ 5, 2 });
	edges[5].push_back({ 2, 4 });

	dijkstra(0);
	print();

	return 0;
}